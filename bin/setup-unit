#!/usr/bin/env bash

#####################################################################
#
# Copyright (C) NGINX, Inc.
# Author:  NGINX Unit Team, F5 Inc.
#
#####################################################################


if test -n ${BASH_VERSION} && test "${BASH_VERSINFO[0]}" -eq 3; then
    >&2 echo 'Your version of bash(1) is not supported by this script.';
    >&2 echo "You're probably running on MacOS.  We recommend that you either";
    >&2 echo 'install a newer version of bash(1), or you run this script with';
    >&2 echo 'another shell, like for example zsh(1):';
    >&2 echo "    $ zsh ${SUDO_USER:+sudo }$0 ...";
    exit 1;
fi;


set -Eefuo pipefail;

test -v BASH_VERSION \
&& shopt -s lastpipe;

export LC_ALL=C

program_name="$0";

dry_run='no';

help_unit()
{
    echo 'SYNOPSIS';
    echo "      $program_name [-h] COMMAND [ARGS]";
    echo;
    echo '   Subcommands';
    echo '      +-- repo-config  [-hn] [PKG-MANAGER OS-NAME OS-VERSION]';
    echo '      +-- welcome      [-hn]';
    echo;
    echo 'DESCRIPTION';
    echo '      This script simplifies installing and configuring';
    echo '      an NGINX Unit server for first-time users.';
    echo;
    echo "      Run '$program_name COMMAND -h' for more information on a command.";
    echo;
    echo 'COMMANDS';
    echo '      repo-config';
    echo '              Configure your package manager with the NGINX Unit';
    echo '              repository for later installation.';
    echo;
    echo '      welcome';
    echo '              Creates an initial configuration to serve a welcome web page'
    echo '              for NGINX Unit.';
    echo;
    echo 'OPTIONS';
    echo '      -h, --help';
    echo '              Print this help.';
    echo;
    echo '      --help-more';
    echo '              Print help for more commands.  They are experimental.';
    echo "              This is not recommended unless you know what you're doing.";
    echo;
}

help_more_unit()
{
    echo 'SYNOPSIS';
    echo "      $program_name [-h] COMMAND [ARGS]";
    echo;
    echo '   Subcommands';
    echo '      +-- cmd          [-h]';
    echo '      +-- ctl          [-h] [-r REMOTE] [-s SOCK] SUBCOMMAND [ARGS]';
    echo '      |   +-- http     [-h] [-c CURLOPT] METHOD PATH';
    echo '      |   +-- insert   [-h] PATH INDEX';
    echo '      +-- freeport     [-h]';
    echo '      +-- json-ins     [-hn] JSON INDEX';
    echo '      +-- os-probe     [-h]';
    echo '      +-- ps           [-h] [-t TYPE]';
    echo '      +-- repo-config  [-hn] [PKG-MANAGER OS-NAME OS-VERSION]';
    echo '      +-- sock         [-h] SUBCOMMAND [ARGS]';
    echo '      |   +-- filter   [-chs]';
    echo '      |   +-- find     [-h]';
    echo '      +-- welcome      [-hn]';
    echo;
    echo 'DESCRIPTION';
    echo '      This script simplifies installing and configuring';
    echo '      an NGINX Unit server for first-time users.';
    echo;
    echo "      Run '$program_name COMMAND -h' for more information on a command.";
    echo;
    echo 'COMMANDS';
    echo '      cmd     Print the invocation line of unitd(8).';
    echo;
    echo '      ctl     Control a running unitd(8) instance through its control socket.';
    echo;
    echo '      freeport';
    echo '              Print an available TCP port.';
    echo;
    echo '      json-ins';
    echo '              Insert a JSON element read from standard input into a JSON';
    echo '              array read from a file at a given INDEX.';
    echo;
    echo '      os-probe';
    echo '              This script probes the OS, and prints details about the version.';
    echo;
    echo '      ps      List unitd(8) processes.';
    echo;
    echo '      repo-config';
    echo '              Configure your package manager with the NGINX Unit';
    echo '              repository for later installation';
    echo;
    echo '      sock    Print the address of the API control socket.';
    echo;
    echo '      welcome Set up a basic configuration on a running instance';
    echo '              of NGINX Unit.';
    echo;
    echo 'OPTIONS';
    echo '      -h, --help';
    echo '              Print the basic help (some commands are hidden).';
    echo;
    echo '      --help-more';
    echo '              Print the hidden help with more commands.';
    echo;
}

warn()
{
    >&2 echo "$(basename $program_name): error: $*";
}

err()
{
    >&2 echo "$(basename $program_name): error: $*";
    exit 1;
}

dry_run_echo()
{
    if test "$dry_run" = "yes"; then
        echo "$*";
    fi;
}

dry_run_eval()
{
    if test "$dry_run" = "yes"; then
        echo "    $*";
    else
        eval "$*";
    fi;
}


unit_cmd()
{
    help_unit_cmd()
    {
        echo 'SYNOPSIS';
        echo "      $program_name cmd [-h]";
        echo;
        echo 'DESCRIPTION';
        echo '      Print the invocation line of running instances of unitd(8).';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_cmd;
            exit 0;
            ;;
        -*)
            >&2 help_unit_cmd;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    unit_ps -t m \
    | sed 's/.*\[\(.*\)].*/\1/';
}


unit_ctl()
{
    help_unit_ctl()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl [-h] [-r REMOTE] [-s SOCK] SUBCOMMAND [ARGS]";
        echo;
        echo '   Subcommands';
        echo '      +-- http    [-h] [-c CURLOPT] METHOD PATH';
        echo '      +-- insert  [-h] PATH INDEX';
        echo;
        echo 'DESCRIPTION';
        echo '      Control a running unitd(8) instance through its control';
        echo '      socket.';
        echo;
        echo "      Run '$program_name ctl SUBCOMMAND -h' for more information";
        echo '      on a subcommand.';
        echo;
        echo 'SUBCOMMANDS';
        echo '      http    Send an HTTP request to the control socket.';
        echo;
        echo '      insert  Insert an element into a specified index in an array';
        echo '              in the JSON configuration.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -s, --sock SOCK';
        echo '              Use SOCK as the API control socket address.  If not';
        echo '              specified, the script will try to find it.  This will';
        echo '              be used by subcommands.';
        echo;
        echo '      -r, --remote REMOTE';
        echo '              Use REMOTE to reach the API control socket through an';
        echo '              ssh(1) tunnel.  The syntax is as specified by ssh(1) as';
        echo "              the 'destination'.  This option requires specifying -s.";
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_ctl;
            exit 0;
            ;;
        -r | --remote)
            if ! test -v 2; then
                >&2 help_unit_ctl;
                exit 1;
            fi;
            local remote="$2";
            shift;
            ;;
        -s | --sock)
            if ! test -v 2; then
                >&2 help_unit_ctl;
                exit 1;
            fi;
            local sock="$2";
            shift;
            ;;
        -*)
            >&2 help_unit_ctl;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test -v remote; then
        if ! test -v sock; then
            >&2 help_unit_ctl;
            exit 1;
        fi;

        local remote_sock="$(echo "$sock" | unit_sock_filter -s)";
        local local_sock="$(mktemp -u -p /var/run/unit/)";
        local ssh_ctrl="$(mktemp -u -p /var/run/unit/)";

        mkdir -p /var/run/unit/;

        ssh -fMNnT -S "$ssh_ctrl" \
                   -o 'ExitOnForwardFailure yes' \
                   -L "$local_sock:$remote_sock" "$remote";

        sock="unix:$local_sock";

    elif ! test -v sock; then
        local sock="$(unit_sock_find)";
    fi;

    if test ! -v 1; then
        >&2 help_unit_ctl;
        exit 1;
    fi;

    case $1 in
    http)
        shift;
        unit_ctl_http ---sock "$sock" $@;
        ;;
    insert)
        shift;
        unit_ctl_insert ---sock "$sock" $@;
        ;;
    *)
        >&2 help_unit_ctl;
        exit 1;
        ;;
    esac;

    if test -v ssh_ctrl; then
        ssh -S "$ssh_ctrl" -O exit "$remote" 2>/dev/null;
        unlink "$local_sock";
    fi;
}


unit_ctl_http()
{
    help_unit_ctl_http()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl [CTL-OPTS] http [-h] [-c CURLOPT] METHOD PATH";
        echo;
        echo 'DESCRIPTION';
        echo '      Send an HTTP request to the unitd(8) control socket.';
        echo;
        echo '      The payload is read from standard input.';
        echo;
        echo 'OPTIONS';
        echo '      -c, --curl CURLOPT';
        echo '              Pass CURLOPT as an option to curl.  This script is';
        echo "              implemented in terms of curl(1), so it's useful to";
        echo '              be able to tweak its behavior.';
        echo;
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo 'EXAMPLES';
        echo "      $program_name ctl http -c --no-progress-meter GET /config >tmp;";
    }

    local curl_options='';

    while test -v 1; do
        case "$1" in
        -c | --curl)
            if test ! -v 2; then
                >&2 help_unit_ctl_http;
                exit 1;
            fi;
            curl_options="$curl_options $2";
            shift;
            ;;
        -h | --help)
            help_unit_ctl_http;
            exit 0;
            ;;
        ---sock)
            local sock="$2";
            shift;
            ;;
        -*)
            >&2 help_unit_ctl_http;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test ! -v 2; then
        >&2 help_unit_ctl_http;
        exit 1;
    fi;

    local method="$1";
    local req_path="$2";

    curl $curl_options -X $method -d@- \
            $(echo "$sock" | unit_sock_filter -c)${req_path};
}


unit_ctl_insert()
{
    help_unit_ctl_insert()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl [CTL-OPTS] insert [-h] PATH INDEX";
        echo;
        echo 'DESCRIPTION';
        echo '      Insert an element into a specified position (INDEX) in the';
        echo '      JSON array in the unitd(8) configuration API at PATH.';
        echo;
        echo '      The new element is read from standard input.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_ctl_insert;
            exit 0;
            ;;
        ---sock)
            local sock="$2";
            shift;
            ;;
        -*)
            >&2 help_unit_ctl_insert;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test ! -v 2; then
        >&2 help_unit_ctl_insert;
        exit 1;
    fi;

    local req_path="$1";
    local idx="$2";

    local old="$(mktemp)";

    unit_ctl_http ---sock "$sock" -c --no-progress-meter GET "$req_path" \
            </dev/null >"$old";

    unit_json_ins "$old" "$idx" \
    | unit_ctl_http ---sock "$sock" PUT "$req_path";
}


unit_ctl_welcome()
{
    help_unit_ctl_welcome()
    {
        echo 'SYNOPSIS';
        echo "      $program_name welcome [-hn]";
        echo;
        echo 'DESCRIPTION';
        echo '      This script tests an NGINX Unit instalation by creating an initial';
        echo '      configuration and serving a welcome web page.  Recommended for';
        echo '      first-time users.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -n, --dry-run';
        echo '              Dry run.  Print the commands to be run instead'
        echo '              of actually running them.  Each command is';
        echo '              preceded by a line explaining what it does.';
    }

    while test -v 1; do
        case "$1" in
        -f | --force)
            local force='yes';
            ;;
        -h | --help)
            help_unit_ctl_welcome;
            exit 0;
            ;;
        -n | --dry-run)
            dry_run='yes';
            ;;
        -*)
            >&2 help_unit_ctl_welcome;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    id -u \
    | xargs test 0 -ne \
    && err 'This script requires root privileges to run.';

    command -v curl >/dev/null \
    || err 'curl(1) not found in PATH.  It must be installed to run this script.';

    www='/srv/www/unit/index.html';
    if test -e "$www" && ! test -v force || ! test -w /srv; then
        www="$(mktemp)";
        mv "$www" "$www.html";
        www="$www.html"
    fi;

    unit_ps -t m \
    | wc -l \
    | read -r nprocs \
    ||:

    if test 0 -eq "$nprocs"; then
        warn "NGINX Unit isn't running.";
        warn 'For help starting NGINX Unit, see:';
        err  "  <https://unit.nginx.org/installation/#startup-and-shutdown>";
    elif test 1 -ne "$nprocs"; then
        err 'Only one NGINX Unit instance should be running.';
    fi;

    local sock="$(unit_sock_find)";
    local curl_opt="$(unit_sock_find | unit_sock_filter -c)";

    curl $curl_opt/ >/dev/null 2>&1 \
    || err "Can't reach the control socket.";

    if ! test -v force; then
        unit_cmd \
        | read -r cmd;

        # Check unitd is not configured already.
        echo "$cmd" \
        | if grep '\--state' >/dev/null; then
            echo "$cmd" \
            | sed 's/ --/\n--/g' \
            | grep '\--state' \
            | cut -d' ' -f2;
        else
            $cmd --help \
            | sed -n '/\--state/,+1p' \
            | grep 'default:' \
            | sed 's/ *default: "\(.*\)"/\1/';
        fi \
        | sed 's,$,/conf.json,' \
        | read -r conffile \
        ||:;

        if test -e $conffile; then
            if ! unit_ctl_http ---sock "$sock" 'GET' '/config' </dev/null 2>/dev/null | grep -q '^{}.\?$';  # The '.\?' is for the possible carriage return.
            then
                warn 'NGINX Unit is already configured.  If you are sure you want';
                err  'to overwrite its current configuration, run again with --force.';
            fi;
        fi;
    fi;

    (
        unit_freeport \
        || err "Can't find an available port.";
    ) \
    | read -r port;

    dry_run_echo 'Create a file to serve:';
    dry_run_eval "mkdir -p $(dirname $www);";
    dry_run_eval "cat >'$www'"' <<__EOF__;
        <!DOCTYPE html>
        <html>
            <head>
                <title>Welcome to NGINX Unit</title>
                <style type="text/css">
                    body { background: white; color: black; font-family: sans-serif; margin: 2em; line-height: 1.5; }
                    h1,h2 { color: #00974d; }
                    li { margin-bottom: 0.5em; }
                    pre { background-color: beige; padding: 0.4em; }
                    hr { margin-top: 2em; border: 1px solid #00974d; }
                    .indent { margin-left: 1.5em; }
                </style>
            </head>
            <body>
                <h1>Welcome to NGINX Unit</h1>
                <p>Congratulations! NGINX Unit is installed and running.</p>
                <h3>Useful Links</h3>
                <ul>
                    <li><b><a href="https://unit.nginx.org/configuration/?referer=welcome">https://unit.nginx.org/configuration/</a></b><br>
                        To get started with Unit, see the <em>Configuration</em> docs, starting with
                        the <em>Quick Start</em> guide.</li>
                    <li><b><a href="https://github.com/nginx/unit">https://github.com/nginx/unit</a></b><br>
                        See our GitHub repo to browse the code, contribute, or seek help from the
                        <a href="https://github.com/nginx/unit#community">community</a>.</li>
                </ul>

                <h2>Next steps</h2>

                <h3>Check Current Configuration</h3>
                <div class="indent">
                <p>Unit'"'"'s control API is currently listening for configuration changes
                   on the '"$(unit_sock_find | grep -q '^unix:' && echo '<a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>' || echo 'socket')"' at
                   <b>'"$(unit_sock_find)"'</b><br>
                   To see the current configuration:</p>
                <pre>'"${SUDO_USER:+sudo }"'curl '"$curl_opt"'/config</pre>
                </div>

                <h3>Change Listener Port</h3>
                <div class="indent">
                <p>This page is served over a random TCP high port.  To choose the default HTTP port (80),
                   replace the <b>"listeners"</b> object:</p>
                <pre>echo '"'"'{"*:80": {"pass": "routes"}}'"'"' | '"${SUDO_USER:+sudo }"'curl -X PUT -d@- '"$curl_opt"'/config/listeners</pre>
                Then remove the port number from the address bar and reload the page.
                </div>

                <hr>
                <p><a href="https://unit.nginx.org/?referer=welcome">NGINX Unit &mdash; the universal web app server</a><br>
                NGINX, Inc. &copy; 2022</p>
            </body>
        </html>
__EOF__';
    dry_run_echo;
    dry_run_echo 'Give it appropriate permissions:';
    dry_run_eval "chmod 644 '$www';";
    dry_run_echo;

    dry_run_echo 'Configure unitd:'
    dry_run_eval "cat <<__EOF__ \\
        | sed 's/8080/$port/' \\
        | curl -X PUT -d@- $curl_opt/config;
        {
            \"listeners\": {
                \"*:8080\": {
                    \"pass\": \"routes\"
                }
            },
            \"routes\": [{
                \"action\": {
                    \"share\": \"$www\"
                }
            }]
        }
__EOF__";

    dry_run_echo;

    echo;
    echo 'You may want to try the following commands now:';
    echo;
    echo 'Check out current unitd configuration:';
    echo "    ${SUDO_USER:+sudo} curl $curl_opt/config";
    echo;
    echo 'Browse the welcome page:';
    echo "    curl http://localhost:$port/";
}


unit_freeport()
{
    help_unit_freeport()
    {
        echo 'SYNOPSIS';
        echo "      $program_name freeport [-h]";
        echo;
        echo 'DESCRIPTION';
        echo '      Print an available TCP port.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_freeport;
            exit 0;
            ;;
        -*)
            >&2 help_unit_freeport;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    freeport="$(mktemp -t freeport-XXXXXX)";

    cat <<__EOF__ \
    | cc -x c -o $freeport -;
        #include <netinet/in.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <strings.h>
        #include <sys/socket.h>
        #include <unistd.h>


        int32_t get_free_port(void);


        int
        main(void)
        {
            int32_t  port;

            port = get_free_port();
            if (port == -1)
                exit(EXIT_FAILURE);

            printf("%d\n", port);
            exit(EXIT_SUCCESS);
        }


        int32_t
        get_free_port(void)
        {
            int                 sfd;
            int32_t             port;
            socklen_t           len;
            struct sockaddr_in  addr;

            port = -1;

            sfd = socket(PF_INET, SOCK_STREAM, 0);
            if (sfd == -1) {
                perror("socket()");
                return -1;
            }

            bzero(&addr, sizeof(addr));
            addr.sin_family = AF_INET;
            addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            addr.sin_port = htons(0);  // random port

            len = sizeof(addr);
            if (bind(sfd, (struct sockaddr *) &addr, len)) {
                perror("bind()");
                goto fail;
            }

            if (getsockname(sfd, (struct sockaddr *) &addr, &len)) {
                perror("getsockname()");
                goto fail;
            }

            port = ntohs(addr.sin_port);

        fail:
            close(sfd);
            return port;
        }
__EOF__

    $freeport;
}


unit_json_ins()
{
    help_unit_json_ins()
    {
        echo 'SYNOPSIS';
        echo "      $program_name json-ins [-hn] JSON INDEX";
        echo;
        echo 'ARGUMENTS';
        echo '      JSON    Path to a JSON file containing a top-level array.';
        echo;
        echo '      INDEX   Position in the array where to insert the element.';
        echo;
        echo 'DESCRIPTION';
        echo '      Insert a JSON element read from standard input into a JSON';
        echo '      array read from a file at a given INDEX.';
        echo;
        echo '      The resulting array is printed to standard output.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -n, --dry-run';
        echo '              Dry run.  Print the command to be run instead';
        echo '              of actually running it.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_json_ins;
            exit 0;
            ;;
        -n | --dry-run)
            dry_run='yes';
            ;;
        -*)
            >&2 help_unit_json_ins;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test ! -v 2; then
        >&2 help_unit_json_ins;
        exit 1;
    fi;

    local arr=$1;
    local idx=$2;

    dry_run_eval "(
        jq '.[0:$idx]' <'$arr';
        echo '[';
        jq .;
        echo ']';
        jq '.[$idx:]' <'$arr';
    ) \\
    | sed '/^\[]$/d' \\
    | sed '/^]$/{N;s/^]\n\[$/,/}' \\
    | jq .;"
}


unit_os_probe()
{
    help_unit_os_probe()
    {
        echo 'SYNOPSIS';
        echo "      $program_name os-probe [-h]";
        echo;
        echo 'DESCRIPTION';
        echo '      This script probes the OS, and prints details about the version.';
        echo "      It prints two fields, delimited by ':'; the first is the package";
        echo '      manager, the second is the OS name, and the third is the OS version.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_os_probe;
            exit 0;
            ;;
        -*)
            >&2 help_unit_os_probe;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    local os=$(uname | tr '[:upper:]' '[:lower:]')

    if [ "$os" != 'linux' ] && [ "$os" != 'freebsd' ]; then
        err "The OS isn't Linux or FreeBSD, can't proceed."
    fi

    if [ "$os" = 'linux' ]; then
        if command -v apt-get >/dev/null; then
            local pkgMngr='apt';
        elif command -v dnf >/dev/null; then
            local pkgMngr='dnf';
        elif command -v yum >/dev/null; then
            local pkgMngr='yum';
        else
            local pkgMngr='';
        fi;

        local osRelease='/etc/os-release';

        if [ -f "$osRelease" ]; then
            # The value for the ID and VERSION_ID may or may not be in quotes
            local osName=$(grep "^ID=" "$osRelease" | sed s/\"//g | awk -F= '{ print $2 }' ||:)
            local osVersion=$(grep '^VERSION_ID=' "$osRelease" | sed s/\"//g | awk -F= '{ print $2 }' || lsb_release -cs)
        else
            err "Unable to determine OS and version, or the OS isn't supported"
        fi
    else
        local pkgMngr='pkg';
        local osName=$os
        local osVersion=$(uname -rs | awk -F '[ -]' '{print $2}' ||:)
        if [ -z "$osVersion" ]; then
            err 'Unable to get the FreeBSD version'
        fi
    fi

    osName=$(echo "$osName" | tr '[:upper:]' '[:lower:]')
    echo "$pkgMngr:$osName:$osVersion"
}


unit_ps()
{
    help_unit_ps()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ps [-h] [-t TYPE]";
        echo;
        echo 'DESCRIPTION';
        echo '      List unitd(8) processes.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -t, --type TYPE';
        echo '              List only processes of type TYPE.  The available';
        echo '              types are:';
        echo;
        echo '              -  controller (c)';
        echo '              -  main (m)';
        echo '              -  router (r)';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_ps;
            exit 0;
            ;;
        -t | --type)
            if test ! -v 2; then
                >&2 help_unit_ps;
                exit 1;
            fi;
            local type=;
            case "$2" in
            c | controller)
                local type_c='c';
                ;;
            m | main)
                local type_m='m';
                ;;
            r | router)
                local type_r='r';
                ;;
            esac;
            shift;
            ;;
        -*)
            >&2 help_unit_ps;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    ps ax \
    | if test -v type; then
        grep ${type_c:+-e 'unit: controller'} \
             ${type_m:+-e 'unit: main'} \
             ${type_r:+-e 'unit: router'};
    else
        grep 'unit: ';
    fi \
    | grep -v grep \
    ||:
}


unit_repo_config()
{
    help_unit_repo_config()
    {
        echo 'SYNOPSIS';
        echo "      $program_name repo-config [-hn] [PKG-MANAGER OS-NAME OS-VERSION]";
        echo;
        echo 'DESCRIPTION';
        echo '      This script configures the NGINX Unit repository for the system';
        echo '      package manager.';
        echo;
        echo '      The script automatically detects your OS, and works accordingly.';
        echo '      However, in case the automatic selection fails, you may specify the';
        echo '      package manager and the OS name and version.';
        echo;
        echo 'ARGUMENTS';
        echo '      PKG-MANAGER';
        echo "              Supported: 'apt', 'dnf', and 'yum'.";
        echo;
        echo '      OS-NAME';
        echo "              Supported: 'debian', 'ubuntu', 'fedora', 'rhel', and 'amzn2'.";
        echo;
        echo '      OS-VERSION';
        echo '              For most distributions this should be a numeric value,';
        echo '              but for debian derivatives, the codename should be used.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -n, --dry-run';
        echo '              Dry run.  Print the commands to be run instead'
        echo '              of actually running them.  Each command is';
        echo '              preceded by a line explaining what it does.';
        echo;
        echo 'EXAMPLES';
        echo "      $ $(basename $program_name) repo-config apt debian bullseye;";
        echo "      $ $(basename $program_name) repo-config apt ubuntu jammy;";
        echo "      $ $(basename $program_name) repo-config dnf fedora 36;";
        echo "      $ $(basename $program_name) repo-config dnf rhel 9;";
        echo "      $ $(basename $program_name) repo-config yum amzn2 2;";
    }

    installAPT ()
    {
        local os_name="$2";

        dry_run_echo "Install on $os_name";
        dry_run_echo;
        dry_run_eval 'curl --output /usr/share/keyrings/nginx-keyring.gpg https://unit.nginx.org/keys/nginx-keyring.gpg;';
        dry_run_echo;
        dry_run_eval 'apt-get install -y apt-transport-https lsb-release ca-certificates;';

        if test -v 3; then
            local os_version="$3";
        else
            local os_version='$(lsb_release -cs)';
        fi;

        dry_run_echo;
        dry_run_eval "printf 'deb [signed-by=/usr/share/keyrings/nginx-keyring.gpg] https://packages.nginx.org/unit/$os_name/ %s unit\n' \"$os_version\" | tee /etc/apt/sources.list.d/unit.list;";
        dry_run_eval "printf 'deb-src [signed-by=/usr/share/keyrings/nginx-keyring.gpg] https://packages.nginx.org/unit/$os_name/ %s unit\n' \"$os_version\" | tee -a /etc/apt/sources.list.d/unit.list;";
        dry_run_echo;
        dry_run_eval 'apt-get update;';
    }

    installYumDnf ()
    {
        local pkg_mngr="$1";
        local os_name="$2";

        if test -v 3; then
            local os_version="$3";
        else
            local os_version='\$releasever';
        fi;

        dry_run_echo "Install on $os_name";
        dry_run_echo;

        dry_run_eval "cat >/etc/yum.repos.d/unit.repo <<__EOF__
[unit]
name=unit repo
baseurl=https://packages.nginx.org/unit/$os_name/$os_version/\\\$basearch/
gpgcheck=0
enabled=1
__EOF__";

        dry_run_echo;
        dry_run_eval "$pkg_mngr makecache;";
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_repo_config;
            exit 0;
            ;;
        -n | --dry-run)
            dry_run='yes';
            ;;
        -*)
            >&2 help_unit_repo_config;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test -v 1 && ! test -v 3; then
        >&2 help_unit_repo_config;
        exit 1;
    fi;
    if test -v 3; then
        local pkg_mngr="$1";
        local os_name="$2";
        local os_version="$3";
    fi;

    command -v curl >/dev/null \
    || err 'curl(1) not found in PATH.  It must be installed to run this script.';

    id -u \
    | xargs test 0 -ne \
    && err 'This script requires root privileges to run.';

    echo 'This script sets up the NGINX Unit repository';

    if test ! -v 3; then
        local os_pkg_name_version=$(unit_os_probe || warn "On macOS, try 'brew install nginx/unit/unit'.")
        local pkg_mngr=$(echo "$os_pkg_name_version" | awk -F: '{print $1}')
        local os_name=$(echo "$os_pkg_name_version" | awk -F: '{print $2}')
        local os_version=$(echo "$os_pkg_name_version" | awk -F: '{print $3}')
    fi;

    # Call the appropriate installation function
    case "$pkg_mngr" in
    apt)
        case "$os_name" in
        debian | ubuntu)
            installAPT "$pkg_mngr" "$os_name" ${3:+$os_version};
            ;;
        *)
            err "'$os_name': The OS isn't supported";
            ;;
        esac
        ;;
    yum | dnf)
        case "$os_name" in
        rhel | amzn | fedora)
            installYumDnf "$pkg_mngr" "$os_name" "$os_version" ${3:+ovr};
            ;;
        *)
            err "'$os_name': The OS isn't supported";
            ;;
        esac;
        ;;
    *)
        err "'$pkg_mngr': The package manager isn't supported";
        ;;
    esac;

    echo
    echo 'All done; the NGINX Unit repository is set up.';
    echo "Configured with '$pkg_mngr' on '$os_name' '$os_version'.";
    echo 'Further steps: <https://unit.nginx.org/installation/#official-packages>'
}


unit_sock()
{
    help_unit_sock()
    {
        echo 'SYNOPSIS';
        echo "      $program_name sock [-h] SUBCOMMAND [ARGS]";
        echo;
        echo '   Subcommands';
        echo '      +-- filter  [-ch]';
        echo '      +-- find    [-h]';
        echo;
        echo 'DESCRIPTION';
        echo '      Print the address of the control API socket of';
        echo '      running instances of unitd(8).';
        echo;
        echo "      Run '$program_name sock SUBCOMMAND -h' for more information";
        echo '      on a subcommand.';
        echo;
        echo 'SUBCOMMANDS';
        echo "      filter  Filter the output of the 'find' subcommand, and transform";
        echo '              it to something suitable to run other commands, such as';
        echo '              curl(1) or ssh(1).';
        echo;
        echo '      find    Find and print the address of the control API socket of';
        echo '              running instances of unitd(8).';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_sock;
            exit 0;
            ;;
        -*)
            >&2 help_unit_sock;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test ! -v 1; then
        >&2 help_unit_sock;
        exit 1;
    fi;

    case $1 in
    filter)
        shift;
        unit_sock_filter $@;
        ;;
    find)
        shift;
        unit_sock_find $@;
        ;;
    *)
        >&2 help_unit_sock;
        exit 1;
        ;;
    esac;
}


unit_sock_filter()
{
    help_unit_sock_filter()
    {
        echo 'SYNOPSIS';
        echo "      $program_name sock filter [-chs]";
        echo;
        echo 'DESCRIPTION';
        echo '      Filter the output of the 'sock find' command, and transform it to';
        echo '      something suitable to run other commands, such as curl(1) or ssh(1).';
        echo;
        echo 'OPTIONS';
        echo '      -c, --curl';
        echo '              Print an argument suitable for curl(1).';
        echo;
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -s, --ssh';
        echo '              Print a socket address suitable for use in an ssh(1) tunnel.';
    }

    while test -v 1; do
        case "$1" in
        -c | --curl)
            if test -v ssh_flag; then
                >&2 help_unit_sock_filter;
                exit 1;
            fi;
            local curl_flag='yes';
            ;;
        -h | --help)
            help_unit_sock_filter;
            exit 0;
            ;;
        -s | --ssh)
            if test -v curl_flag; then
                >&2 help_unit_sock_filter;
                exit 1;
            fi;
            local ssh_flag='yes';
            ;;
        -*)
            >&2 help_unit_sock_filter;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    while read -r control; do

        if test -v curl_flag; then
            if echo "$control" | grep '^unix:' >/dev/null; then
                unix_socket="$(echo "$control" | sed 's/unix:/--unix-socket /')";
                host='localhost';
            else
                unix_socket='';
                host="$control";
            fi;

            echo "$unix_socket http://$host";

        elif test -v ssh_flag; then
            echo "$control" \
            | sed 's%^unix:%%';

        else
            echo "$control";
        fi;
    done;
}


unit_sock_find()
{
    help_unit_sock_find()
    {
        echo 'SYNOPSIS';
        echo "      $program_name sock find [-h]";
        echo;
        echo 'DESCRIPTION';
        echo '      Find and print the address of the control API socket of';
        echo '      running instances of unitd(8).';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            help_unit_sock_find;
            exit 0;
            ;;
        -*)
            >&2 help_unit_sock_find;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    unit_cmd \
    | while read -r cmd; do
        if echo "$cmd" | grep '\--control' >/dev/null; then
            echo "$cmd" \
            | sed 's/ --/\n--/g' \
            | grep '\--control' \
            | cut -d' ' -f2;
        else
            $cmd --help \
            | sed -n '/\--control/,+1p' \
            | grep 'default:' \
            | sed 's/ *default: "\(.*\)"/\1/';
        fi;
    done;
}


while test -v 1; do
    case "$1" in
    -h | --help)
        help_unit;
        exit 0;
        ;;
    --help-more)
        help_more_unit;
        exit 0;
        ;;
    -*)
        >&2 help_unit;
        exit 1;
        ;;
    *)
        break;
        ;;
    esac;
    shift;
done;

if test ! -v 1; then
    >&2 help_unit;
    exit 1;
fi;

case $1 in
cmd)
    shift;
    unit_cmd $@;
    ;;
ctl)
    shift;
    unit_ctl $@;
    ;;
freeport)
    shift;
    unit_freeport $@;
    ;;
json-ins)
    shift;
    unit_json_ins $@;
    ;;
os-probe)
    shift;
    unit_os_probe $@;
    ;;
ps)
    shift;
    unit_ps $@;
    ;;
repo-config)
    shift;
    unit_repo_config $@;
    ;;
sock)
    shift;
    unit_sock $@;
    ;;
welcome)
    shift;
    unit_ctl_welcome $@;
    ;;
*)
    >&2 help_unit;
    exit 1;
    ;;
esac;
