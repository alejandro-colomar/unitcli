#!/usr/bin/env bash

#####################################################################
#
# Copyright (C) NGINX, Inc.
# Author:  NGINX Unit Team, F5 Inc.
#
#####################################################################

set -Eefuo pipefail;
shopt -s lastpipe;

export LC_ALL=C

program_name="$0";

dry_run='no';

print_help()
{
    echo 'SYNOPSIS';
    echo "      $program_name [-h] COMMAND [ARGS]";
    echo;
    echo 'DESCRIPTION';
    echo '      This script simplifies installing and configuring';
    echo '      an NGINX Unit server for first-time users.';
    echo;
    echo "      Run '$program_name COMMAND -h' for more information on a command.";
    echo;
    echo 'COMMANDS';
    echo '      ctl     Control a running unitd(8) instance through its control socket.';
    echo;
    echo '      freeport';
    echo '              Print an available TCP port.';
    echo;
    echo '      ps      List unitd(8) processes.';
    echo;
    echo '      repo-config';
    echo '              Configure your package manager with the NGINX Unit';
    echo '              repository for later installation';
    echo;
    echo 'OPTIONS';
    echo '      -h, --help';
    echo '              Print this help.';
    echo;
}

warn()
{
    >&2 echo "$*";
}

err()
{
    >&2 echo "$*";
    exit 1;
}

dry_run_echo()
{
    if test "$dry_run" = "yes"; then
        echo "$*";
    fi;
}

dry_run_eval()
{
    if test "$dry_run" = "yes"; then
        echo "    $*";
    else
        eval "$*";
    fi;
}

repo_config()
{
    print_help_repo_config()
    {
        echo 'SYNOPSIS';
        echo "      $program_name repo-config [-hn]";
        echo;
        echo 'DESCRIPTION';
        echo '      This script configures the NGINX Unit repository';
        echo '      on Amazon Linux, CentOS, Debian, Fedora, Oracle Linux, Red Hat, or Ubuntu.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -n, --dry-run';
        echo '              Dry run.  Print the commands to be run instead'
        echo '              of actually running them.  Each command is';
        echo '              preceded by a line explaining what it does.';
    }

    #####################################################################
    # Function getOS
    #
    # Getting the OS is not the same on all distributions.  First, we use
    # uname to find out if we are running on Linux or FreeBSD. For all the
    # supported versions of Debian and Ubuntu, we expect to find the
    # /etc/os-release file which has multiple lines with name-value pairs
    # from which we can get the OS name and version. For Red Hat and its
    # variants, the os-release file may or may not exist, depending on the
    # version.  If it doesn't, then we look for the release package and
    # get the OS and version from the package name. For FreeBSD, we use the
    # "uname -rs" command.
    #
    # A string is written to stdout with three values separated by ":":
    #    OS
    #    OS Name
    #    OS Version
    #####################################################################
    getOS ()
    {
        os=$(uname | tr '[:upper:]' '[:lower:]')

        if [ "$os" != "linux" ] && [ "$os" != "freebsd" ]; then
            warn "Error: The OS isn't Linux or FreeBSD, can't proceed."
            err  "On macOS, try 'brew install nginx/unit/unit'."
        fi

        if [ "$os" = "linux" ]; then
            osRelease="/etc/os-release";

            if [ -f "$osRelease" ]; then
                # The value for the ID and VERSION_ID may or may not be in quotes
                osName=$( grep "^ID=" "$osRelease" | sed s/\"//g | awk -F= '{ print $2 }')
                osVersion=$(grep "^VERSION_ID=" "$osRelease" | sed s/\"//g | awk -F= '{ print $2 }')
            else
                # rhel or centos 6.*
                if rpm -q redhat-release-server >/dev/null 2>&1; then
                    osName=rhel
                    osVersion=$(rpm -q redhat-release-server |sed 's/.*-//' | awk -F. '{print $1"."$2;}')
                elif rpm -q centos-release >/dev/null 2>&1; then
                    osName=centos
                    osVersion=$(rpm -q centos-release | sed 's/centos-release-//' | sed 's/\..*//' | awk -F- '{print $1"."$2;}')
                else
                    err "Error: Unable to determine OS and version, or the OS isn't supported"
                fi
            fi
        else
            osName=$os
            osVersion=$(uname -rs | awk -F '[ -]' '{print $2}')
            if [ -z "$osVersion" ]; then
                err "Unable to get the FreeBSD version"
            fi
        fi

        # Force osName to lowercase
        osName=$(echo "$osName" | tr '[:upper:]' '[:lower:]')
        echoDebug "getOS: os=$os osName=$osName osVersion=$osVersion"
        echo "$os:$osName:$osVersion"
    }


    installDebian ()
    {
        dry_run_echo 'Install on Debian';
        dry_run_echo;
        dry_run_eval 'curl --output /usr/share/keyrings/nginx-keyring.gpg https://unit.nginx.org/keys/nginx-keyring.gpg;';
        dry_run_echo;
        dry_run_eval 'apt install -y apt-transport-https lsb-release ca-certificates;';
        dry_run_echo;
        dry_run_eval 'printf "deb [signed-by=/usr/share/keyrings/nginx-keyring.gpg] https://packages.nginx.org/unit/debian/ %s unit\n" "$(lsb_release -cs)" | tee /etc/apt/sources.list.d/unit.list;';
        dry_run_eval 'printf "deb-src [signed-by=/usr/share/keyrings/nginx-keyring.gpg] https://packages.nginx.org/unit/debian/ %s unit\n" "$(lsb_release -cs)" | tee -a /etc/apt/sources.list.d/unit.list;';
        dry_run_echo;
        dry_run_eval 'apt update;';
    }

    installUbuntu ()
    {
        dry_run_echo 'Install on Ubuntu';
        dry_run_echo;
        dry_run_eval 'curl --output /usr/share/keyrings/nginx-keyring.gpg https://unit.nginx.org/keys/nginx-keyring.gpg;';
        dry_run_echo;
        dry_run_eval 'apt install -y apt-transport-https lsb-release ca-certificates;';
        dry_run_echo;
        dry_run_eval 'printf "deb [signed-by=/usr/share/keyrings/nginx-keyring.gpg] https://packages.nginx.org/unit/ubuntu/ %s unit\n" "$(lsb_release -cs)" | tee /etc/apt/sources.list.d/unit.list;';
        dry_run_eval 'printf "deb-src [signed-by=/usr/share/keyrings/nginx-keyring.gpg] https://packages.nginx.org/unit/ubuntu/ %s unit\n" "$(lsb_release -cs)" | tee -a /etc/apt/sources.list.d/unit.list;';
        dry_run_echo;
        dry_run_eval 'apt update;';
    }

    installRedHat ()
    {
        dry_run_echo 'Install on Red Hat/CentOS/Oracle';
        dry_run_echo;

        case "$osVersion" in
            6|6.*|7|7.*|8|8.*)
                dry_run_eval "cat << __EOF__ > /etc/yum.repos.d/unit.repo
[unit]
name=unit repo
baseurl=https://packages.nginx.org/unit/rhel/\$releasever/\$basearch/
gpgcheck=0
enabled=1
__EOF__";
                ;;
            *)
                echo "Unsupported $osName version: $osVersion"
                exit 1
                ;;
        esac

        dry_run_echo;
        dry_run_eval 'yum makecache;';
    }

    installAmazon ()
    {
        dry_run_echo 'Install on Amazon';
        dry_run_echo;

        case "$osVersion" in
            2)
                dry_run_eval "cat << __EOF__ > /etc/yum.repos.d/unit.repo
[unit]
name=unit repo
baseurl=https://packages.nginx.org/unit/amzn2/\$releasever/\$basearch/
gpgcheck=0
enabled=1
__EOF__";
             ;;
            *)
                dry_run_eval "cat << __EOF__ > /etc/yum.repos.d/unit.repo
[unit]
name=unit repo
baseurl=https://packages.nginx.org/unit/amzn/\$releasever/\$basearch/
gpgcheck=0
enabled=1
__EOF__";
             ;;
        esac

        dry_run_echo;
        dry_run_eval 'yum makecache;';
    }

    installFedora ()
    {
        dry_run_echo 'Install on Fedora';
        dry_run_echo;

        dry_run_eval "cat << __EOF__ > /etc/yum.repos.d/unit.repo
[unit]
name=unit repo
baseurl=https://packages.nginx.org/unit/fedora/\$releasever/\$basearch/
gpgcheck=0
enabled=1
__EOF__";

        dry_run_echo;
        dry_run_eval 'dnf makecache;';
    }

    echoDebug ()
    {
        if [ "$debug" -eq 1 ]; then
            echo "$@" 1>&2;
        fi
    }

    debug=0 # If set to 1, debug message will be displayed

    while test -v 1; do
        case "$1" in
        -h | --help)
            print_help_repo_config;
            exit 0;
            ;;
        -n | --dry-run)
            dry_run='yes';
            ;;
        -*)
            >&2 print_help_repo_config;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    command -v curl >/dev/null \
    || err "Error: curl not found in PATH.  It must be installed to run this script."

    id -u \
    | xargs test 0 -ne \
    && err "This script requires root privileges to run."

    echo "This script sets up the NGINX Unit repository"

    osNameVersion=$(getOS)
    os=$(echo "$osNameVersion" | awk -F: '{print $1}')
    osName=$(echo "$osNameVersion" | awk -F: '{print $2}')
    osVersion=$(echo "$osNameVersion" | awk -F: '{print $3}')

    # Call the appropriate installation function
    case "$osName" in
    debian)
        installDebian
        ;;
    ubuntu)
        installUbuntu
        ;;
    rhel)
        installRedHat
        ;;
    centos)
        installRedHat
        ;;
    ol)
        installRedHat
        ;;
    amzn)
        installAmazon
        ;;
    fedora)
        installFedora
        ;;
    *)
        err "$osName isn't supported"
        ;;
    esac

    echo
    echo "All done; the NGINX Unit repository for "$osName" "$osVersion" is set up."
    echo "Further steps: https://unit.nginx.org/installation/#official-packages"
}


unit_freeport()
{
    print_help_unit_freeport()
    {
        echo 'SYNOPSIS';
        echo "      $program_name freeport [-h]";
        echo;
        echo 'DESCRIPTION';
        echo '      Print an available TCP port.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            print_help_unit_freeport;
            exit 0;
            ;;
        -*)
            >&2 print_help_unit_freeport;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    freeport="$(mktemp -t freeport-XXXXXX)";

    cat <<__EOF__ \
    | cc -x c -o $freeport -;
        #include <netinet/in.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <strings.h>
        #include <sys/socket.h>
        #include <unistd.h>


        int32_t get_free_port(void);


        int
        main(void)
        {
            int32_t  port;

            port = get_free_port();
            if (port == -1)
                exit(EXIT_FAILURE);

            printf("%d\n", port);
            exit(EXIT_SUCCESS);
        }


        int32_t
        get_free_port(void)
        {
            int                 sfd;
            int32_t             port;
            socklen_t           len;
            struct sockaddr_in  addr;

            port = -1;

            sfd = socket(PF_INET, SOCK_STREAM, 0);
            if (sfd == -1) {
                perror("socket()");
                return -1;
            }

            bzero(&addr, sizeof(addr));
            addr.sin_family = AF_INET;
            addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
            addr.sin_port = htons(0);  // random port

            len = sizeof(addr);
            if (bind(sfd, (struct sockaddr *) &addr, len)) {
                perror("bind()");
                goto fail;
            }

            if (getsockname(sfd, (struct sockaddr *) &addr, &len)) {
                perror("getsockname()");
                goto fail;
            }

            port = ntohs(addr.sin_port);

        fail:
            close(sfd);
            return port;
        }
__EOF__

    $freeport;
}


unit_ctl()
{
    print_help_unit_ctl()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl [-h] SUBCOMMAND [ARGS]";
        echo;
        echo 'DESCRIPTION';
        echo '      Control a running unitd(8) instance through its control';
        echo '      socket.';
        echo;
        echo "      Run '$program_name ctl SUBCOMMAND -h' for more information";
        echo '      on a subcommand.';
        echo;
        echo 'SUBCOMMANDS';
        echo '      http    Send an HTTP request to the control socket.';
        echo;
        echo '      insert  Insert an element into a specified index in an array';
        echo '              in the JSON configuration.';
        echo;
        echo '      sock    Print the address of the control socket.';
        echo;
        echo '      welcome Set up a basic configuration on a running instance';
        echo '              of NGINX Unit.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            print_help_unit_ctl;
            exit 0;
            ;;
        -*)
            >&2 print_help_unit_ctl;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test ! -v 1; then
        >&2 print_help_unit_ctl;
        exit 1;
    fi;

    case $1 in
    http)
        shift;
        unit_ctl_http $@;
        ;;
    insert)
        shift;
        unit_ctl_insert $@;
        ;;
    sock)
        shift;
        unit_ctl_sock $@;
        ;;
    welcome)
        shift;
        unit_ctl_welcome $@;
        ;;
    *)
        >&2 print_help;
        exit 1;
        ;;
    esac;
}


unit_ctl_sock()
{
    print_help_unit_ctl_sock()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl sock [-ch]";
        echo;
        echo 'DESCRIPTION';
        echo '      Print the address of the control socket.';
        echo;
        echo 'OPTIONS';
        echo '      -c, --curl';
        echo '              Print an argument suitable for curl(1).';
        echo;
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -c | --curl)
            local curl_opt='yes';
            ;;
        -h | --help)
            print_help_unit_ctl_sock;
            exit 0;
            ;;
        -*)
            >&2 print_help_unit_ctl_sock;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    unit_cmd \
    | read -r cmd;

    echo "$cmd" \
    | if grep '\--control' >/dev/null; then
        echo "$cmd" \
        | sed 's/ --/\n--/g' \
        | grep '\--control' \
        | cut -d' ' -f2;
    else
        $cmd --help \
        | sed -n '/\--control/,+1p' \
        | grep 'default:' \
        | sed 's/ *default: "\(.*\)"/\1/';
    fi \
    | read -r control;

    if ! test -v curl_opt; then
        echo "$control";
        return 0;
    fi;

    if echo "$control" | grep '^unix:' >/dev/null; then
        unix_socket="$(echo "$control" | sed 's/unix:/--unix-socket /')";
        host='localhost';
    else
        unix_socket='';
        host="$control";
    fi;

    echo "$unix_socket http://$host";
}


unit_ctl_insert()
{
    print_help_unit_ctl_insert()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl insert [-h] PATH INDEX";
        echo;
        echo 'DESCRIPTION';
        echo '      Insert an element into a specified position (INDEX) in the';
        echo '      JSON array in the unitd(8) configuration API at PATH.';
        echo;
        echo '      The new element is read from standard input.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            print_help_unit_ctl_insert;
            exit 0;
            ;;
        -n | --dry-run)
            dry_run='yes';
            ;;
        -*)
            >&2 print_help_unit_ctl_insert;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test ! -v 2; then
        >&2 print_help_unit_ctl_insert;
        exit 1;
    fi;

    local path="$1";
    local idx="$2";

    local old="$(mktemp)";
    local old="$(mktemp)";
    local elem="$(mktemp)";

    unit_ctl_sock -c \
    | read -r curl_opt;

    curl -X GET ${curl_opt}${path} >"$old" 2>/dev/null;

    cat >"$elem";

    unit_jq_insert "$old" "$elem" "$idx" \
    | unit_ctl_http PUT "$path";
}


unit_ctl_http()
{
    print_help_unit_ctl_http()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl http [-hn] METHOD PATH";
        echo;
        echo 'DESCRIPTION';
        echo '      Send an HTTP request to the unitd(8) control socket.';
        echo;
        echo '      The payload is read from standard input.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -n, --dry-run';
        echo '              Dry run.  Print the command to be run instead'
        echo '              of actually running it.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            print_help_unit_ctl_http;
            exit 0;
            ;;
        -n | --dry-run)
            dry_run='yes';
            ;;
        -*)
            >&2 print_help_unit_ctl_http;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    if test ! -v 2; then
        >&2 print_help_unit_ctl_http;
        exit 1;
    fi;

    local method="$1";
    local path="$2";

    unit_ctl_sock -c \
    | read -r curl_opt;

    dry_run_eval "curl -X $method -d@- ${curl_opt}${path};";
}


unit_ctl_welcome()
{
    print_help_unit_ctl_welcome()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ctl welcome [-hn]";
        echo;
        echo 'DESCRIPTION';
        echo '      This script simplifies configuring a running';
        echo '      NGINX Unit instance for first-time users.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -n, --dry-run';
        echo '              Dry run.  Print the commands to be run instead'
        echo '              of actually running them.  Each command is';
        echo '              preceded by a line explaining what it does.';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            print_help_unit_ctl_welcome;
            exit 0;
            ;;
        -n | --dry-run)
            dry_run='yes';
            ;;
        -*)
            >&2 print_help_unit_ctl_welcome;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    id -u \
    | xargs test 0 -ne \
    && err "This script requires root privileges to run."

    command -v curl >/dev/null \
    || err "Error: curl not found in PATH.  It must be installed to run this script."

    www="/srv/www/unit/index.html";
    test -e "$www" \
    && www="$(mktemp)";

    unit_cmd \
    | read -r cmd;

    # Check unitd is not configured already.
    echo "$cmd" \
    | if grep '\--state' >/dev/null; then
        echo "$cmd" \
        | sed 's/ --/\n--/g' \
        | grep '\--state' \
        | cut -d' ' -f2;
    else
        $cmd --help \
        | sed -n '/\--state/,+1p' \
        | grep 'default:' \
        | sed 's/ *default: "\(.*\)"/\1/';
    fi \
    | sed 's,$,/conf.json,' \
    | xargs test -e \
    && err 'NGINX Unit is already configured.'

    unit_ctl_sock -c \
    | read -r curl_opt;

    curl $curl_opt/ >/dev/null 2>&1 \
    || err "Can't reach the control socket.";

    (
        unit_freeport \
        || err "Can't find an available port.";
    ) \
    | read -r port;

    dry_run_echo 'Create a file to serve:';
    dry_run_eval "mkdir -p $(dirname $www);";
    dry_run_eval "echo 'Welcome to NGINX Unit!' >'$www';";
    dry_run_echo;
    dry_run_echo 'Give it appropriate permissions:';
    dry_run_eval "chmod 644 '$www';";
    dry_run_echo;

    dry_run_echo 'Configure unitd:'
    dry_run_eval "cat <<__EOF__ \\
        | sed 's/8080/$port/' \\
        | curl -X PUT -d@- $curl_opt/config/;
        {
            \"listeners\": {
                \"*:8080\": {
                    \"pass\": \"routes\"
                }
            },
            \"routes\": [{
                \"action\": {
                    \"share\": \"$www\"
                }
            }]
        }
__EOF__";

    dry_run_echo;

    echo
    echo "You may want to try the following commands now:"
    echo
    echo "Check out current unitd configuration:"
    echo "    curl $curl_opt"
    echo
    echo "Browse the welcome page:"
    echo "    curl http://localhost:$port";
}


unit_ps()
{
    print_help_unit_ps()
    {
        echo 'SYNOPSIS';
        echo "      $program_name ps [-h] [-t TYPE]";
        echo;
        echo 'DESCRIPTION';
        echo '      List unitd(8) processes.';
        echo;
        echo 'OPTIONS';
        echo '      -h, --help';
        echo '              Print this help.';
        echo;
        echo '      -t, --type TYPE';
        echo '              List only processes of type TYPE.  The available';
        echo '              types are:';
        echo;
        echo '              -  controller (c)';
        echo '              -  main (m)';
        echo '              -  router (r)';
    }

    while test -v 1; do
        case "$1" in
        -h | --help)
            print_help_unit_ps;
            exit 0;
            ;;
        -t | --type)
            local type=;
            case "$2" in
            c | controller)
                local type_c='c';
                ;;
            m | main)
                local type_m='m';
                ;;
            r | router)
                local type_r='r';
                ;;
            esac;
            shift;
            ;;
        -*)
            >&2 print_help_unit_ps;
            exit 1;
            ;;
        *)
            break;
            ;;
        esac;
        shift;
    done;

    ps ax \
    | if test -v type; then
        grep ${type_c:+-e 'unit: controller'} \
             ${type_m:+-e 'unit: main'} \
             ${type_r:+-e 'unit: router'};
    else
        grep 'unit: ';
    fi \
    | grep -v grep \
    ||:
}


unit_cmd()
{
    unit_ps -t m \
    | wc -l \
    | read -r nprocs \
    ||:

    test 0 -eq "$nprocs" \
    && err "NGINX Unit isn't running.";

    test 1 -ne "$nprocs" \
    && err "Only one NGINX Unit instance should be running.";

    unit_ps -t m \
    | sed 's/.*\[\(.*\)].*/\1/';
}


unit_jq_insert()
{
    local arr=$1;
    local elem=$2;
    local idx=$3;

    (
        jq ".[0:$idx]" <"$arr";
        echo '[';
        jq . <"$elem";
        echo ']';
        jq ".[$idx:]" <"$arr";
    ) \
    | sed '/^\[]$/d' \
    | sed '/^]$/{N;s/^]\n\[$/,/}' \
    | jq .;
}


while test -v 1; do
    case "$1" in
    -h | --help)
        print_help;
        exit 0;
        ;;
    -*)
        >&2 print_help;
        exit 1;
        ;;
    *)
        break;
        ;;
    esac;
    shift;
done;

if test ! -v 1; then
    >&2 print_help;
    exit 1;
fi;

case $1 in
ctl)
    shift;
    unit_ctl $@;
    ;;
freeport)
    shift;
    unit_freeport $@;
    ;;
ps)
    shift;
    unit_ps $@;
    ;;
repo-config)
    shift;
    repo_config $@;
    ;;
*)
    >&2 print_help;
    exit 1;
    ;;
esac;
